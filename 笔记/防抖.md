# Debounce

## 基本原理:
DOM 事件里的 debounce 概念其实是从机械开关和继电器的“去弹跳”（debounce）衍生 出来的，基本思路就是把多个信号合并为一个信号。

在 JavaScript 中，debounce 函数所做的事情就是，强制一个函数在某个连续时间段内只执行一次，哪怕它本来会被调用多次。我们希望在用户停止某个操作一段时间之后才执行相应的监听函数，而不是在用户操作的过程当中，浏览器触发多少次事件，就执行多少次监听函数。

比如，在某个 3s 的时间段内连续地移动了鼠标，浏览器可能会触发几十（甚至几百）个 mousemove 事件，不使用 debounce 的话，监听函数就要执行这么多次；如果对监听函数使用 100ms 的“去弹跳”，那么浏览器只会执行一次这个监听函数，而且是在第 3.1s 的时候执行的。

现在，我们就来实现一个 debounce 函数。

我们这个 debounce 函数接收两个参数，第一个是要“去弹跳”的回调函数 fn，第二个是延迟的时间 delay。

## HTML DOM addEventListener() 方法
addEventListener() 方法用于向指定元素添加事件句柄。
### 语法格式
element.addEventListener(event, function, useCapture)
参数值：
|参数|描述|
|:----|:----|
|event|必须。字符串，指定事件名。注意: 不要使用 "on" 前缀。 例如，使用 "click" ,而不是使用 "onclick"。|
|function|必须。指定要事件触发时执行的函数。当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， "click" 事件属于 MouseEvent(鼠标事件) 对象。|
|useCapture|可选。布尔值，指定事件是否在捕获或冒泡阶段执行。|

## 对象的拓展运算符
拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象。

## Debounce
debounce函数同样可以减少函数触发的频率，但限制的方式有点不同。当函数触发时，使用一个定时器延迟执行操作。当函数被再次触发时，清除已设置的定时器，重新设置定时器。如果上一次的延迟操作还未执行，则会被清除。一个最常见的业务场景是监听onchange事件，根据用户输入进行搜索，获取远程数据。为避免多次ajax请求，使用debounce函数作为onchange的回调。由debounce的用途可知，实现延迟回调需要用到setTimeout设置定时器，每次重新触发时需要清除原来的定时器并重新设置，简单的代码实现如下：

我们会对一些触发频率较高的事件进行监听，如果在回调里执行高性能消耗的操作，反复触发时会使得性能消耗提高，浏览器卡顿，用户使用体验差。或者我们需要对触发的事件延迟执行回调，此时可以借助throttle/debounce函数来实现需求。

throttle函数用于限制函数触发的频率，每个delay时间间隔，最多只能执行函数一次。一个最常见的例子是在监听resize/scroll事件时，为了性能考虑，需要限制回调执行的频率，此时便会使用throttle函数进行限制。由throttle函数的定义可知，每个delay时间间隔，最多只能执行函数一次，所以需要有一个变量来记录上一个执行函数的时刻，再结合延迟时间和当前触发函数的时刻来判断当前是否可以执行函数。在设定的时间间隔内，函数最多只能被执行一次。同时，第一次触发时立即执行函数。以下为throttle实现的简略代码：

## 概念

频繁触发,但只在特定的时间内没有触发执行条件才执行一次代码


